# base-service

## Что меняем при форке репы
your-service/internal/config/config.go
your-service/go.mod
your-service/cmd/main.go


## Правила работы с репозиторием
1. Работа с ветками (Git Flow Light)
   Используем упрощенную модель Git Flow. Основная ветка — main (или master). Любое изменение кода происходит через Pull Request (PR).
   Именование веток
   Формат: тип/номер-задачи_краткое-описание
* feature/ — для нового функционала.
    * Пример: feature/HOCH-38AuthMiddleware
* bugfix/ — для исправления ошибок.
    * Пример: bugfix/HOCH-38FixNilPinter
* hotfix/ — срочные правки на продакшн (идут в обход обычного цикла).
    * Пример: hotfix/HOCH-38criticalSecurityPatch
      Требования к PR
* Small PRs: Один PR — одна задача. Если кода больше 400 строк, его нужно разбивать.
* Linter & Tests: PR не принимается, если не проходят тесты или линтер (golangci-lint).
* Review: Минимум 1 одобрение (approve) от другого разработчика или тимлида.
3. Семантическое версионирование (SemVer)
   Мы используем формат vX.Y.Z:
* X (Major): Обратно несовместимые изменения API.
* Y (Minor): Новый функционал с сохранением совместимости.
* Z (Patch): Багфиксы и мелкие правки.
  Работа с тегами
* Тег ставится только на ветку main после слияния PR.
* Имя тега должно соответствовать версии: v1.2.3.
* Для каждого сервиса в монорепозитории (если используете) тег включает имя сервиса: auth/v1.0.2.
3. Пайплайн реализации фичи
   Пошаговый алгоритм для джуна:
* Обсуждение: Перед кодингом проговорить архитектурное решение с тимлидом (5-10 мин).
* Ветка: Создать ветку от актуального main.
* Локальная разработка:
    * Код должен соответствовать Uber Go Style Guide.
    * Написание Unit-тестов обязано покрывать основной сценарий.
* Сборка: Проверка, что go mod tidy выполнен и проект компилируется.
* Push & PR: Создание Draft PR для раннего фидбека или обычного PR для ревью.
4. Пайплайн деплоя
   Процесс автоматизирован через CI/CD (например, GitLab CI или GitHub Actions).
   Сценарий A: Фичи и обычные багфиксы
* Merge в main: После аппрува ветка вливается в main.
* Staging Deploy: Автоматический деплой в тестовую среду (Staging/Dev).
* QA: Проверка функционала в окружении.
* Tagging: Создание Git-тега (например, v1.1.0).
* Production Deploy: После создания тега запускается пайплайн деплоя на прод.
  Сценарий B: Hotfix (Критический баг)
* Создается ветка hotfix/ от последнего стабильного тега или main.
* Исправление + тест.
* Срочный PR и деплой на Staging.
* Слияние в main и немедленный выпуск патч-версии (v1.1.1).
5. Специфика Go в команде
* Обработка ошибок: Никаких «пустых» if err != nil { return err } без контекста. Использовать fmt.Errorf("context: %w", err).
* Линтеры: Обязательное использование golangci-lint с включенными govet, errcheck, staticcheck.
* Логи: Использовать структурированное логирование (например, slog или zap).